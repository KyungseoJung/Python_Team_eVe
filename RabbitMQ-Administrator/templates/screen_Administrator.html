<!-- // T-Map appkey = 5RB8KXlDuB6uLZGhugCqS9OJMViZ73P93dRPbphu -->

<!-- 
//#26 관리자(Administrator) 웹화면 디자인 구성 
//#27 관리자 웹페이지 디자인 
//#28 수리모형 코드 통합 - [경로 계산하기] 버튼 누르면, 수리모형 코드 실행되도록 - csv 파일 지정한 파일 위치에 저장되도록
//#29 배터리 강화학습 코드 통합

//#30 [주문 관리] 페이지 
//#30-2 [주문 관리] 페이지 - 테이블 및 지도 동적 기능
//#30-3 RabbitMQ로부터 데이터를 수신해서 표에 표시(screen_Driver.html과 통신)

//#31 디자인
//#32 [전략 도출] 페이지 - 테이블 생성 및 표시 & 로딩바 표시
//#33 Driver의 수만큼 다른 웹페이지 실행되도록 & driver_id에 따라 다른 RabbitMQ 주소를 부여받고, 각각 다른 주소로 데이터를 송신하도록
//#33-1 지도에 표시
//#33-2 드라이버 정보 표로 표시(driver_id, 상태, 다음 도착지)
//#33-3 드라이버 업무 진척도를 [수평 진행률 표시줄]을 통해 표현
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>관리자 페이지</title>
    <!-- //#29 차트 보여주기 위해 필요 -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- //#30 [주문 관리] 페이지에서 "도로명 주소" 얻기 위함 -->
    <script src="https://apis.openapi.sk.com/tmap/js?version=1&appKey=5RB8KXlDuB6uLZGhugCqS9OJMViZ73P93dRPbphu"></script>
    <!-- //#30 [주문 관리] 페이지에서 지도 보여주기 위함 -->
    <script src="https://apis.openapi.sk.com/tmap/vectorjs?version=1&appKey=5RB8KXlDuB6uLZGhugCqS9OJMViZ73P93dRPbphu"></script>

    <!-- #30-3 RabbitMQ로부터 데이터를 수신해서 표에 표시 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/sockjs-client/dist/sockjs.min.js"></script> -->

    <!-- //#33 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

    <style>
      /* //#27
      Body나 HTML 태그의 마진 또는 패딩: 기본적으로 브라우저는 HTML 페이지의 body 태그에 마진이나 패딩을 자동으로 추가하기 때문에 공백이 발생할 수 있음
      -> 이를 제거하려면 CSS에서 body와 html 태그의 마진과 패딩을 0으로 설정해야 함.
      불필요한 태그나 공백: HTML 코드 내에 불필요한 공백이나 태그가 있을 경우 이를 정리함. */
      html,
      body {
        margin: 0;
        padding: 0;
      }
      body {
        font-family: Arial, sans-serif;
      }
      .navbar {
        /* //#27 불필요한 공백 제거 */
        margin-top: 0;
        padding-top: 0;

        background: #333;
        padding: 10px 40px;
        color: white;
        text-align: right;
      }
      .button {
        color: white;
        background: gray;
        padding: 10px 40px;
        border: none;
        cursor: pointer;
        margin-right: 10px;
        font-size: 17px; /* Larger font size */
      }
      .button.active {
        background: red;
      }
      /* ============= //#28 [전략 도출] 페이지 - 여기부터 =============--> */
      .button-check {
        /* color: white;
        background: gray;
        padding: 10px 20px;
        border: none;
        cursor: pointer;
        margin-right: 10px; */

        color: black;
        background: #ffd8d8; /* Dark grey background */
        border: 1.5px solid #000000;
        padding: 10px 40px; /* Larger buttons */
        cursor: pointer;
        font-size: 20px; /* Larger font size */
        border-radius: 5px; /* Rounded corners */
      }
      .button-calculate {
        color: white;
        background: #000000; /* Dark grey background */
        border: 1.5px solid #ffffff;
        padding: 10px 20px; /* Larger buttons */
        cursor: pointer;
        font-size: 20px; /* Larger font size */
        border-radius: 5px; /* Rounded corners */
      }
      #content {
        /* //#27 불필요한 공백 제거 */
        margin-top: 0;
        padding-top: 0;

        padding: 20px;
        display: flex;
        /* //#33-2 추가 */
        flex-direction: column; /* Stack vertically */
        justify-content: space-between; /* Distribute space */
        align-items: stretch; /* Align items to stretch full width */

        width: 100%; /* Ensures the container takes full width */
        /* max-width: 1200px;  */
        /* Adjust this value based on your design requirements */
        margin: 0 auto; /* Centers the content block horizontally */

        /* justify-content: space-around; */
      }
      /* //#33-2 */
      .top-panels {
        display: flex;
        justify-content: space-between; /* Aligns children side by side*/
        width: 100%; /* Ensures the container takes full width */
      }
      /* //#33-2 각 panel들이 다른 크기를 갖고 있어야 한다면, 이 부분 설정해야 함 */
      .top-panels .panel {
        width: 48%;
        /* Adjust based on margin or padding between panels */
      }
      .panel {
        flex: 1; /* //#33-2 각 panel이 동일한 범위를 차지하도록 */
        border: 1px solid #ccc;
        padding: 10px;
        margin: 20px; /* 간격을 위해 margin 설정 */
      }
      .panel:nth-child(3) {
        /* //#33-2 Specifically target the third panel */
        width: 100%;
      }
      .section {
        display: none;
        flex: 1;
        margin: 0 10px;
        border: 1px solid #ccc;
        padding: 10px;
      }
      .visible {
        display: flex;
      }
      /* table,
      th,
      td {
        border: 1px solid black;
        border-collapse: collapse;
        padding: 8px;
      } */
      table {
        border: 1px solid #006ab1; /* Light blue border */

        width: 100%; /* Full width to use available space */
        border-collapse: collapse; /* Ensures borders are merged */
      }

      th,
      td {
        border: 1px solid #2c5282; /* Navy blue border for readability */
        text-align: left; /* Align text to the left */
        padding: 12px 15px; /* Comfortable padding around text */
        word-wrap: break-word; /* Prevents text overflow */
      }

      th {
        background-color: #2980b9; /* Slightly lighter navy color for headers */
        font-weight: bold; /* Make header fonts bold */
      }

      tr:nth-child(odd) {
        background-color: #34495e; /* Zebra striping for rows */
      }

      tr:hover {
        background-color: #3498db; /* Highlight on hover for better interaction feedback */
      }

      /* Specifically target the street address column for wider display */
      td:last-child,
      th:last-child {
        min-width: 200px; /* Minimum width */
        max-width: 300px; /* Maximum width */
      }

      .hidden {
        display: none;
      }
      .loader-container {
        display: flex;
        align-items: center;
        margin-top: 20px;
        margin-bottom: 20px;
        gap: 20px;
      }
      .loader {
        width: 100px;
        height: 20px;
        background: gray;
      }
      /* .loader-bar {
        height: 100%;
        background: lightgreen;
        width: 0%;
      } */
      /* complete 됐을 때, 초록색으로 로딩바 가득 채우기 */
      .complete {
        background-color: green;
        width: 100% !important;
      }
      .disabled {
        pointer-events: none;
        opacity: 0.4;
      }
      /* #27 데이터 테이블 스크롤 가능하도록 */
      /* #31 디자인 추가 */
      .table-container {
        overflow-x: auto; /* Allows horizontal scrolling if the table is too wide */
        max-width: 700px;
        max-height: 400px; /* Set a maximum height */

        background-color: #2c3e50; /* Dark navy background */
        color: #ecf0f1; /* White text for better readability */
        border-radius: 8px; /* Rounded corners */
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Subtle shadow for depth */
        padding: 15px; /* Padding around the table */
      } /* Scrollable container */

      /* //#32 로딩 이미지 */
      .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border-left-color: #09f;

        animation: spin 1s infinite linear;
      }
      /* //#32 로딩 이미지 */
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* ============= //#28 [전략 도출] 페이지 - 여기까지 =============--> */

      /* ============= //#30 [주문 관리] 페이지 - 여기부터 ============= */

      /* ============= //#30 [주문 관리] 페이지 - 여기까지 ============= */

      /* ============= //#33 [배달 관리] 페이지 - 여기부터 ============= */
      #driverWorkProcess {
        width: 100%;
        padding: 10px;
        background-color: #f4f4f4;
        border-radius: 5px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin: 20px 0;
      }

      .progress-bar {
        width: calc(100% - 40px); /* Adjust width for padding */
        background-color: #ddd;
        border-radius: 5px;
        margin-bottom: 10px;
        position: relative; /* For positioning the driver ID absolutely */
        padding: 5px; /* Padding inside the progress bar */
        box-sizing: border-box; /* Include padding in width calculation */
      }

      .segment {
        background-color: #eee;
        height: 20px;
        float: left;
        border-right: 1px solid #ccc; /* Visual separator */
        box-sizing: border-box;
      }

      .segment:last-child {
        border-right: none;
      }

      .driver-id {
        position: absolute;
        left: 0;
        top: 0;
        padding: 5px 10px;
        background-color: rgba(255, 255, 255, 0.9);
        border-top-left-radius: 4px;
        border-bottom-right-radius: 4px;
      }
      .segment.complete {
        background-color: #4caf50; /* Green background for completed segments */
      }

      /* ============= //#33 [배달 관리] 페이지 - 여기까지 ============= */

      /* ============= //#29 [배터리 관리] 페이지 - 여기부터 ============= */
      /* //#29 배터리 관리 페이지 - 차트 style 지정 */
      .chart-container {
        width: 400px;
        height: 400px;
        display: inline-block;
      }
      /* ============= //#29 [배터리 관리] 페이지 - 여기까지 ============= */
    </style>
  </head>
  <body>
    <div class="navbar">
      <button class="button active" onclick="showSection('appendAndSolve')">
        전략 도출
      </button>
      <button class="button" onclick="showSection('orderCheck')">
        주문 확인
      </button>
      <button class="button" onclick="showSection('delivery')">
        배달 관리
      </button>
      <button class="button" onclick="showSection('battery')">
        배터리 관리
      </button>
    </div>
    <div id="content">
      <!-- ============= //#28 [전략 도출] 페이지 - 수리모형 코드 통합 - 여기부터 =============-->
      <div id="appendAndSolve" class="section visible">
        <div class="panel">
          <h2>주문 데이터 확인</h2>
          <button class="button-check" onclick="loadOrderData()">
            <img
              src="https://cdn-icons-png.flaticon.com/128/9159/9159105.png"
              alt="Load Icon"
              style="
                height: 30px;
                width: 30px;
                vertical-align: middle;
                margin-right: 5px;
              "
            />

            실시간 주문 데이터
          </button>
          <div class="table-container">
            <table id="orderTable"></table>
          </div>
        </div>
        <div class="panel">
          <h2>전략 도출</h2>
          <button class="button-calculate" onclick="calculatePath()">
            <img
              src="https://cdn-icons-png.flaticon.com/128/9422/9422848.png"
              alt="Load Icon"
              style="
                height: 30px;
                width: 30px;
                vertical-align: middle;
                margin-right: 5px;
              "
            />
            전략 도출하기
          </button>
          <div class="loader-container hidden">
            <div class="spinner hidden"></div>

            <!-- // #32 로딩바 완료 메시지 -->
            <span id="completeLabel" class="hidden"
              >Complete! 파일 저장 완료</span
            >
          </div>
        </div>
      </div>
      <!-- ============= //#28 [전략 도출] 페이지 - 수리모형 코드 통합 - 여기까지 =============-->

      <!-- ============= //#30 [주문 관리] 페이지 - 여기부터 =============-->
      <div id="orderCheck" class="section">
        <div class="panel">
          <h2>확정 주문 데이터</h2>
          <button class="button-check" onclick="loadConfirmedOrderData()">
            <img
              src="https://cdn-icons-png.flaticon.com/128/9159/9159105.png"
              alt="Load Icon"
              style="
                height: 30px;
                width: 30px;
                vertical-align: middle;
                margin-right: 5px;
              "
            />

            확정 주문 데이터
          </button>
          <div class="table-container">
            <table id="confirmedOrderTable"></table>
          </div>
        </div>
        <div class="panel">
          <h2>주문 Map</h2>
          <button class="button-check" onclick="initOrderMap()">
            <img
              src="https://cdn-icons-png.flaticon.com/128/854/854878.png"
              alt="Load Icon"
              style="
                height: 30px;
                width: 30px;
                vertical-align: middle;
                margin-right: 5px;
              "
            />

            주문 Map 불러오기
          </button>

          <div id="orderMapDiv" style="width: 100%; height: 400px"></div>
        </div>
      </div>
      <!-- ============= //#30 [주문 관리] 페이지 - 여기까지 =============-->

      <!-- ============= //[배달 관리] 페이지 - 여기부터 =============-->
      <div id="delivery" class="section">
        <!-- //#33-2 화면 구획화 -->
        <div id="content">
          <div class="top-panels">
            <!-- Panel1 //#33-2 Driver 정보를 표로 표시 -->
            <div class="panel">
              <h2>Driver Table</h2>
              <div class="table-container">
                <table id="driverStatusTable"></table>
              </div>
            </div>
            <!-- Panel2 #33 -->
            <!-- initOrderMap, orderMapDiv, 변수(orderMap) 데이터를 Driver로 바꾸기 -->
            <div class="panel">
              <h2>Driver Map</h2>
              <button class="button-check" onclick="initDriverMap()">
                <img
                  src="https://cdn-icons-png.flaticon.com/128/854/854878.png"
                  alt="Load Icon"
                  style="
                    height: 30px;
                    width: 30px;
                    vertical-align: middle;
                    margin-right: 5px;
                  "
                />

                Driver Map 불러오기
              </button>

              <div id="driverMapDiv" style="width: 100%; height: 400px"></div>
            </div>
          </div>

          <!-- Panel3 -->
          <div class="panel">
            <h2>Driver Work Process</h2>
            <button class="button-check">
              <img
                src="https://cdn-icons-png.flaticon.com/128/265/265707.png"
                alt="Progress Icon"
                style="
                  height: 30px;
                  width: 30px;
                  vertical-align: middle;
                  margin-right: 5px;
                "
              />

              Driver 업무 진척도 확인
            </button>
            <!-- #33-3 -->
            <div
              id="driverWorkProcess"
              style="width: 100%; overflow-x: auto"
            ></div>
            <!-- Container for the progress bars -->
          </div>
        </div>
      </div>
      <!-- ============= //[배달 관리] 페이지 - 여기까지 =============-->

      <div id="battery" class="section">
        <!-- ============= //#29 배터리 강화학습 코드 통합 - 여기부터=============-->
        <h2>Battery State of Charge</h2>
        <div id="charts">
          <!-- 5 canvas elements for 5 charts -->
          <div class="chart-container">
            <canvas id="batteryChart0" width="400" height="400"></canvas>
          </div>
          <div class="chart-container">
            <canvas id="batteryChart1" width="400" height="400"></canvas>
          </div>
          <div class="chart-container">
            <canvas id="batteryChart2" width="400" height="400"></canvas>
          </div>
          <div class="chart-container">
            <canvas id="batteryChart3" width="400" height="400"></canvas>
          </div>
          <div class="chart-container">
            <canvas id="batteryChart4" width="400" height="400"></canvas>
          </div>
        </div>
        <!-- ============= //#29 배터리 강화학습 코드 통합 - 여기까지=============-->
      </div>
    </div>

    <script>
      //  ============= //#28 [전략 도출] 페이지 - 수리모형 코드 통합 - 여기부터 =============

      //#27 경로 계산 전에는 버튼 비활성화 되어 있도록  //#30 주석처리
      // document.querySelectorAll(".button-check").forEach((btn) => {
      //   btn.classList.add("disabled");
      // });

      function showSection(section) {
        document.querySelectorAll(".section").forEach((sec) => {
          sec.classList.remove("visible");
        });
        document.querySelectorAll(".button").forEach((btn) => {
          btn.classList.remove("active");
          btn.disabled = false; // Enable all buttons
        });
        document.getElementById(section).classList.add("visible");
        document
          .querySelector(`.button[onclick="showSection('${section}')"]`)
          .classList.add("active");
      }

      function calculatePath() {
        disableButtons(); // 다른 버튼들 모두 비활성화

        const loaderContainer = document.querySelector(".loader-container");
        const spinner = document.querySelector(".spinner");
        const completeLabel = document.getElementById("completeLabel");
        loaderContainer.classList.remove("hidden"); // #32 로딩 박스 보이도록
        spinner.classList.remove("hidden"); // #32 로딩 동그라미 돌아가는 모습 보이도록
        //#28 ======================= 수리모형 함수 넣기 -> 주석처리 여기부터
        // loaderBar.style.width = "0%";
        // let width = 0;
        // const interval = setInterval(() => {
        //   if (width >= 100) {
        //     clearInterval(interval);
        //     alert("경로 계산 완료");
        //     // loaderBar.style.width = "0%";
        //     loaderBar.className = "loader-bar complete"; // 경로 계산 마침 - 계속 초록색으로 로딩바 채워져 있도록 (Complete!)
        //     completeLabel.classList.remove("hidden");
        //     loaderContainer.classList.add("hidden");
        //     enableButtons(); // 다른 버튼들 모두 활성화
        //   } else {
        //     width++;
        //     loaderBar.style.width = `${width}%`;
        //   }
        // }, 10);
        //#28 ======================= 수리모형 함수 넣기 -> 주석처리 여기까지

        fetch("/calculate_path", { method: "POST" }) // POST request -> Flask로 요청
          .then((response) => response.json())
          .then((data) => {
            if (data.success) {
              // loaderBar.style.width = "100%"; // #28 로딩바 100% 채우기
              alert("전략 도출 완료 + CSV 저장 완료");

              // 기존 코드 - 버튼 비활성화/ 활성화
              // loaderBar.className = "loader-bar complete"; // 경로 계산 마침 - 계속 초록색으로 로딩바 채워져 있도록 (Complete!)
              completeLabel.classList.remove("hidden");
              // loaderContainer.classList.add("hidden"); // #32 로딩 동그라미 돌아가는 모습 안 보이도록
              // enableButtons(); // 다른 버튼들 모두 활성화
            } else {
              alert("에러 발생: " + data.message);
            }
          })
          .catch((error) => {
            alert("통신 오류: " + error);
            console.log(error);
          })
          .finally(() => {
            loaderContainer.classList.add("hidden"); // #32 모두 완료되면, 로딩 동그라미 다시 숨기기
            spinner.classList.add("hidden");
            enableButtons(); // 다른 버튼들 모두 활성화
          });
      }

      function disableButtons() {
        document.querySelectorAll(".button").forEach((btn) => {
          btn.classList.add("disabled");
        });
        //#27 이미 비활성화 되어있음
        // document.querySelectorAll(".button-check").forEach((btn) => {
        //   btn.classList.add("disabled");
        // });
        document.querySelectorAll(".button-calculate").forEach((btn) => {
          btn.classList.add("disabled");
        });
      }

      function enableButtons() {
        document.querySelectorAll(".button").forEach((btn) => {
          btn.classList.remove("disabled");
        });
        document.querySelectorAll(".button-check").forEach((btn) => {
          btn.classList.remove("disabled");
        });
        //#27
        // document.querySelectorAll(".button-calculate").forEach((btn) => {
        //   btn.classList.remove("disabled");
        // });
      }

      function saveFile() {
        alert("파일이 저장되었습니다!");
      }

      // function loadCSVData() {
      //   fetch("/static/deliveries.csv")
      //     .then((response) => response.text())
      //     .then((data) => {
      //       const rows = data.split("\n").map((row) => row.split(","));
      //       const table = document.getElementById("data-table");
      //       table.innerHTML = ""; // Clear previous data
      //       rows.forEach((row, index) => {
      //         const tr = document.createElement("tr");
      //         row.forEach((cell) => {
      //           const td = document.createElement("td");
      //           td.textContent = cell;
      //           tr.appendChild(td);
      //         });
      //         table.appendChild(tr);
      //       });
      //     })
      //     .catch((error) => {
      //       alert("Error loading data: " + error);
      //     });
      // }

      // #32 [전략 도출] 페이지 - 좌측 표 생성
      function loadOrderData() {
        fetch("/static/orders.csv")
          .then((response) => response.text())
          .then((data) => {
            // const rows = data.split("\n").map((row) => row.split(","));
            // Filters out empty rows and checks for non-empty first cell
            //#30 비어있는 행(empty rows)을 확인(=row에 2개 이상에 데이터가 있는지 확인) && 1번째 셀이 비어있는지 확인 - 비어있는 csv 파일을 보이도록 하지 않기 위해
            const rows = data
              .split("\n")
              .map((row) => row.split(","))
              .filter((row) => row.length > 1 && row[0]);

            // #28 latitude,longitude 컬럼 제외하고 "도로명주소" 컬럼 추가
            const headers = rows[0]; // headers가 1번째 행에 있다고 가정
            const latIndex = headers.indexOf("latitude"); // 새로운 column 삭제
            const lonIndex = headers.indexOf("longitude"); // 새로운 column 삭제
            headers.push("도로명주소"); // 새로운 column 추가

            // 테이블 생성
            const table = document.getElementById("orderTable");
            table.innerHTML = ""; // 이전 데이터 Clear

            // header 행 생성
            const headerRow = document.createElement("tr");
            headers.forEach((header) => {
              const th = document.createElement("th");
              th.textContent = header;
              headerRow.appendChild(th);
            });
            table.appendChild(headerRow);

            // 각 데이터 행 처리
            const dataRows = rows.slice(1); // header에 해당하는 행은 제외하고~ 시작
            Promise.all(
              dataRows.map((row) => {
                const latitude = row[latIndex];
                const longitude = row[lonIndex];

                console.log("Latitude:", latitude, "Longitude:", longitude); // #30 debug 목적 코드

                return getAddress(latitude, longitude).then((address) => {
                  row.push(address); // 도로명주소 데이터를 row 값에 추가
                  return row;
                });
              })
            ).then((processedRows) => {
              // processedRows.forEach((row) => { // #30-2 주석처리 (row) -> (row, index)
              processedRows.forEach((row, index) => {
                const tr = document.createElement("tr");
                row.forEach((cell) => {
                  const td = document.createElement("td");
                  td.textContent = cell;
                  tr.appendChild(td);
                });
                // #30-2 테이블 클릭하면, 지도에 표시되도록
                tr.onclick = () =>
                  highlightClientData(
                    index,
                    parseFloat(row[latIndex]),
                    parseFloat(row[lonIndex])
                  );

                table.appendChild(tr);
              });
            });
          })
          .catch((error) => {
            alert("Error loading data: " + error);
          });
      }

      //  ============= //#28 [전략 도출] 페이지 - 수리모형 코드 통합 - 여기까지 =============

      //  ============= //#30 [주문 관리] 페이지 - 여기부터 =============
      var orderMap;
      var markers = []; // Global array to hold markers
      var selectedMarker = null; // To keep track of the selected marker
      var stompClient; // #30-2 미리 선언

      // #30 latitude,longitude를 통해서 "도로명 주소"를 column으로 나타내기
      function loadConfirmedOrderData() {
        fetch("/static/orders.csv")
          .then((response) => response.text())
          .then((data) => {
            // const rows = data.split("\n").map((row) => row.split(","));
            // Filters out empty rows and checks for non-empty first cell
            //#30 비어있는 행(empty rows)을 확인(=row에 2개 이상에 데이터가 있는지 확인) && 1번째 셀이 비어있는지 확인 - 비어있는 csv 파일을 보이도록 하지 않기 위해
            const rows = data
              .split("\n")
              .map((row) => row.split(","))
              .filter((row) => row.length > 1 && row[0]);

            // #28 latitude,longitude 컬럼 제외하고 "도로명주소" 컬럼 추가
            const headers = rows[0]; // headers가 1번째 행에 있다고 가정
            const latIndex = headers.indexOf("latitude"); // 새로운 column 삭제
            const lonIndex = headers.indexOf("longitude"); // 새로운 column 삭제
            headers.push("도로명주소1"); // 새로운 column 추가

            // 테이블 생성
            const table = document.getElementById("confirmedOrderTable");
            table.innerHTML = ""; // 이전 데이터 Clear

            // header 행 생성
            const headerRow = document.createElement("tr");
            headers.forEach((header) => {
              const th = document.createElement("th");
              th.textContent = header;
              headerRow.appendChild(th);
            });
            table.appendChild(headerRow);

            // 각 데이터 행 처리
            const dataRows = rows.slice(1); // header에 해당하는 행은 제외하고~ 시작
            Promise.all(
              dataRows.map((row) => {
                const latitude = row[latIndex];
                const longitude = row[lonIndex];

                console.log("Latitude:", latitude, "Longitude:", longitude); // #30 debug 목적 코드

                return getAddress(latitude, longitude).then((address) => {
                  row.push(address); // 도로명주소 데이터를 row 값에 추가
                  return row;
                });
              })
            ).then((processedRows) => {
              // processedRows.forEach((row) => { // #30-2 주석처리 (row) -> (row, index)
              processedRows.forEach((row, index) => {
                const tr = document.createElement("tr");
                row.forEach((cell) => {
                  const td = document.createElement("td");
                  td.textContent = cell;
                  tr.appendChild(td);
                });
                // #30-2 테이블 클릭하면, 지도에 표시되도록
                tr.onclick = () =>
                  highlightClientData(
                    index,
                    parseFloat(row[latIndex]),
                    parseFloat(row[lonIndex])
                  );

                table.appendChild(tr);
              });
            });
          })
          .catch((error) => {
            alert("Error loading data: " + error);
          });
      }

      // #30 위도, 경도를 바탕으로 도로명 주소 return
      function getAddress(latitude, longitude) {
        // 오류 발생 시, 잡아서 처리할 수 있도록
        return new Promise((resolve, reject) => {
          // #30 에러 확인용 코드
          if (!latitude || !longitude) {
            reject("Latitude or longitude is undefined");
            return;
          }

          var xhr = new XMLHttpRequest();
          xhr.open(
            "GET",
            `https://apis.openapi.sk.com/tmap/geo/reversegeocoding?version=1&lat=${latitude}&lon=${longitude}&appKey=5RB8KXlDuB6uLZGhugCqS9OJMViZ73P93dRPbphu`
          );
          xhr.onload = () => {
            if (xhr.status === 200) {
              var response = JSON.parse(xhr.responseText);
              resolve(response.addressInfo.fullAddress); // Return the full address
            } else {
              reject("Failed to fetch address");
            }
          };
          xhr.onerror = () => {
            reject("Network request failed");
          };
          xhr.send();
        });
      }

      // #30 고객 주문 정보를 Map으로 보여주기
      // 지도 시작 및 업데이트
      function initOrderMap() {
        fetch("/static/orders.csv")
          .then((response) => response.text())
          .then((data) => {
            const rows = data.split("\n").map((row) => row.split(","));
            if (rows.length < 2) return; // Ensure there is data

            // 지도에 마커 표시하기 위함
            const headers = rows[0];
            const latIndex = headers.indexOf("latitude");
            const lonIndex = headers.indexOf("longitude");
            // 지도에 툴팁으로 고객 정보 표시하기 위함
            // const clientIndex = headers.indexOf("client_id");
            // const chargeAmountIndex = headers.indexOf("charge_amount");

            let latSum = 0,
              lonSum = 0,
              validCount = 0;

            rows.slice(1).forEach((row) => {
              // 지도에 마커 표시하기 위함
              const latitude = parseFloat(row[latIndex]);
              const longitude = parseFloat(row[lonIndex]);

              if (!isNaN(latitude) && !isNaN(longitude)) {
                latSum += latitude;
                lonSum += longitude;
                validCount++;
              }
            });

            if (validCount > 0) {
              const centerLat = latSum / validCount;
              const centerLon = lonSum / validCount;

              //이미 지도 활성화 되었다면, just reset the center and clear old markers
              if (orderMap) {
                orderMap.setCenter(new Tmapv3.LatLng(centerLat, centerLon));
                clearMarkers(); // 이미 markers가 존재한다면, Clear
              } else {
                // (첫 활성화) 지도 활성화 - Initialize the map for the first time
                orderMap = new Tmapv3.Map("orderMapDiv", {
                  center: new Tmapv3.LatLng(centerLat, centerLon),
                  width: "100%",
                  height: "400px",
                  zoom: 12,
                });
              }

              // 마커들 Load and display
              loadMarkers(
                rows,
                latIndex,
                lonIndex
                // clientIndex,
                // chargeAmountIndex
              );
            }
          })
          .catch((error) => console.error("Error loading CSV data:", error));
      }

      // 지도에서 모든 markers Clear
      function clearMarkers() {
        markers.forEach((marker) => marker.setMap(null)); // 지도에서 모든 markers 삭제
        markers = []; // Reset the markers array
      }

      // 지도에 markers 로드하는 함수
      function loadMarkers(
        rows,
        latIndex,
        lonIndex
        // clientIndex,
        // chargeAmountIndex
      ) {
        rows.slice(1).forEach((row) => {
          // 지도에 마커 표시하기 위함
          const latitude = parseFloat(row[latIndex]);
          const longitude = parseFloat(row[lonIndex]);

          if (!isNaN(latitude) && !isNaN(longitude)) {
            // Ensure coordinates are valid
            let marker = new Tmapv3.Marker({
              // title: `Client ID: ${clientId}, Charge: ${chargeAmount}`, // Simple tooltip
              // title: "강조",
              label: "Driver",

              position: new Tmapv3.LatLng(latitude, longitude),
              map: orderMap,
            });
            markers.push(marker); //marker 저장
          }
        });
      }

      // #30-2 [주문 관리] 페이지 - 테이블 동적 기능
      function highlightClientData(index, lat, lon) {
        // ============ 테이블 하이라이트 ============
        // Reset any previously selected row
        document.querySelectorAll("#confirmedOrderTable tr").forEach((tr) => {
          // tr.style.backgroundColor = ""; // Reset background color
          if (tr.style.backgroundColor != "green") {
            // Only reset rows that are not marked complete
            tr.style.backgroundColor = ""; // Reset background color
          }
        });

        // Highlight the new selected row
        const selectedRow = document.querySelector(
          `#confirmedOrderTable tr:nth-child(${index + 2})`
        ); // +2 because nth-child is 1-based and includes header
        if (selectedRow.style.backgroundColor != "green") {
          // Do not change color if already marked complete
          selectedRow.style.backgroundColor = "red";
        }

        // ============ 지도 하이라이트 ============
        // 지도가 초기화되지 않았다면, initOrderMap 함수를 호출
        if (!orderMap) {
          initOrderMap();
        }
        // 새로운 선택을 한 마커 외의 다른 마커들은 원상태로 (Reset the icon of the previously selected marker)
        if (selectedMarker) {
          selectedMarker.setMap(null); // Remove the old marker

          let newMarker = new Tmapv3.Marker({
            position: new Tmapv3.LatLng(
              selectedMarker.getPosition().lat(),
              selectedMarker.getPosition().lng()
            ),
            map: orderMap,
          });
          markers[selectedMarkerIndex] = newMarker; // Replace the old marker with the new one
        }

        // 새로 선택한 고객의 마커 하이라이트 표시 (Set the new selected marker)
        selectedMarker = markers[index];
        selectedMarkerIndex = index; // Keep track of the selected index
        selectedMarker.setMap(null); // Remove the old marker
        selectedMarker = new Tmapv3.Marker({
          position: new Tmapv3.LatLng(lat, lon),
          map: orderMap,
          // icon: "https://cdn-icons-png.flaticon.com/128/14034/14034740.png",
          icon: "/static/image/redMarker.png",
          size: new Tmapv3.Size(0.1, 0.1), // 아이콘의 크기 설정
        });
        markers[index] = selectedMarker; // Update the array with the new highlighted marker
      }

      // #30-3 RabbitMQ 통신
      function connectToRabbitMQ() {
        var ws = new WebSocket("ws://127.0.0.1:15674/ws");
        stompClient = Stomp.over(ws);
        stompClient.connect(
          "guest",
          "guest",
          function (frame) {
            console.log("//#30-3 Connected: " + frame);

            subscribeCompleteTopics(); // #33 함수로 분리화 - 서비스완료(즉, "수거완료") 받았는지 확인

            subscribeDriverTopics(); // #33 Driver들의 실시간 위치 얻기

            // #33-2 RabbitMQ로부터 Driver들의 서비스 상태를 얻기
            // #33-3 Driver의 업무 진척도 [수평 진행률] 업데이트
            subscribeDriverStateTopics();
          },
          function (error) {
            console.log("WebSocket error: " + error);
          }
        );
      }

      function subscribeCompleteTopics() {
        // Subscribe to a pattern if possible, or a general topic that gets all messages
        var subscribeTopic = "/topic/serviceComplete";

        stompClient.subscribe(subscribeTopic, function (message) {
          console.log("//#30-3 데이터 수신 - 고객 ID: " + message.body);
          updateRowColor(message.body);
        });
      }

      function updateRowColor(clientId) {
        var table = document.getElementById("confirmedOrderTable");
        var columnIndex = 0; // Assume client_id is the first column, adjust if necessary
        // Find the index for 'client_id' column
        var headers = table.rows[0].cells;
        for (var j = 0; j < headers.length; j++) {
          if (headers[j].textContent.trim().toLowerCase() === "client id") {
            columnIndex = j;
            break;
          }
        }
        // Change row color to green where client_id matches
        for (var i = 1; i < table.rows.length; i++) {
          var row = table.rows[i];
          if (row.cells[columnIndex].textContent.trim() === clientId) {
            row.style.backgroundColor = "green";
            break;
          }
        }
      }

      // connectToRabbitMQ() 함수를 통해 RabbitMQ 통신 시작
      // connectToRabbitMQ(); // #33 - 밑에서 fetchDrivers 완료 후, 따로 실행

      //  ============= //#30 [주문 관리] 페이지 - 여기까지 =============

      //  ============= //#33 [배달 관리] 페이지 - 여기부터 =============
      var drivers = []; // #33 driverId 고유값들로만 이루어진 배열(Array)
      var driverMap; // #33-1 배달기사들의 위치를 지도에 표시
      var driverMarkers = {}; // #33-1 배달기사들의 위치를 마커로 표시

      // #33 Driver들의 위치 얻기
      function subscribeDriverTopics() {
        // console.log("//#33 drivers 배열: " + drivers);

        drivers.forEach((driverId) => {
          // console.log("//#33 driver forEach로 살피기: " + driverId);
          var subscribeDriverTopic = "/topic/driverLocation" + driverId;
          stompClient.subscribe(subscribeDriverTopic, function (message) {
            // updateDriverLocation(driverId, message.body);
            console.log(
              "//#33 배달 ID: " + driverId + ", 메시지: " + message.body
            );
            var driverLocation = JSON.parse(message.body);

            // #33-1 배달 기사들의 위치를 지도에 표시
            updateDriverMap(
              driverLocation.latitude,
              driverLocation.longitude,
              driverId
            );
          });
        });
      }

      function fetchDrivers() {
        fetch("/static/deliveries.csv")
          .then((response) => response.text())
          .then((csvText) => {
            var data = Papa.parse(csvText, { header: true }).data;
            var driverIds = new Set(); // driver_id의 고유값(즉, 종류)을 저장하기 위한 Set 설정
            data.forEach((row) => driverIds.add(row.driver_id));
            drivers = Array.from(driverIds); // driver_id의 고유값을 배열(Array)로 넣기
            console.log(
              "//#33 driver_id 고유값들을 배열(drivers)로 완성" + drivers
            );

            connectToRabbitMQ(); // driver_id의 값을 모두 얻은 후에는 RabbitMQ 연결하고 & Subsribe
          })
          .catch((err) => console.error("Error loading CSV data:", err));
      }

      // #33-2 RabbitMQ로부터 Driver들의 서비스 상태를 얻기
      function subscribeDriverStateTopics() {
        // Subscribe to a pattern if possible, or a general topic that gets all messages
        var subscribeDriverStateTopic = "/topic/driverStatus";

        stompClient.subscribe(subscribeDriverStateTopic, function (message) {
          var driverStateData = JSON.parse(message.body);
          console.log("//#33-2 데이터 수신: " + driverStateData);
          console.log("//#33-2 드라이버 ID: " + driverStateData.driverId);
          console.log("//#33-2 드라이버 상태: " + driverStateData.status);
          console.log(
            "//#33-2 드라이버 다음 도착지 위도: " + driverStateData.latitude
          );
          console.log(
            "//#33-2 드라이버 다음 도착지 경도: " + driverStateData.longitude
          );

          updateDriverTable(driverStateData); // #33-2 드라이버 데이터들을 표로 나타내기

          updateProgressBar(driverStateData); // #33-3 Driver의 업무 진척도 [수평 진행률] 업데이트
        });
      }

      // #33-2 드라이버들의 데이터를 표로 표시
      function updateDriverTable(data) {
        var table = document.getElementById("driverStatusTable"); // Ensure you have a table with this ID in your HTML
        if (!table) {
          console.error("Table element not found.");
          return;
        }

        // 테이블 표의 header가 존재하지 않는다면, 생성
        if (table.rows.length === 0) {
          let header = table.createTHead();
          let headerRow = header.insertRow(0);
          ["Driver ID", "State", "다음 도착지"].forEach((headerText) => {
            let th = document.createElement("th");
            th.innerText = headerText;
            headerRow.appendChild(th);
          });
        }

        // #33-2 fix: 위도 또는 경도가 0이면 주소를 빈 문자열로 설정
        var address =
          data.latitude === 0 || data.longitude === 0
            ? "-"
            : getAddress(data.latitude, data.longitude);

        // #33-2 Retrieve the address using the latitude and longitude
        // getAddress(data.latitude, data.longitude)  // #33-2 fix 주석 처리
        Promise.resolve(address)
          .then((address) => {
            // Assuming data contains properties `driverId`, `status`, and `nextDestination`
            var row = document.querySelector(`#driver-${data.driverId}`);
            if (!row) {
              row = table.insertRow(-1);
              row.id = `driver-${data.driverId}`;
              row.insertCell(0).innerText = data.driverId; // Driver ID
              row.insertCell(1).innerText = data.status; // State
              row.insertCell(2).innerText = address; // Address
              // row.insertCell(3).innerText = data.longitude; // Longitude
              // row.insertCell(4).innerText = data.latitude; // Latitude
            } else {
              // Update the existing row
              row.cells[1].innerText = data.status;
              row.cells[2].innerText = address;
              // row.cells[3].innerText = data.longitude;
              // row.cells[4].innerText = data.latitude;
            }
          })
          .catch((error) => {
            console.error("Failed to fetch address: " + error);
          });
      }

      function getAddress(latitude, longitude) {
        return new Promise((resolve, reject) => {
          var xhr = new XMLHttpRequest();
          xhr.open(
            "GET",
            `https://apis.openapi.sk.com/tmap/geo/reversegeocoding?version=1&lat=${latitude}&lon=${longitude}&appKey=5RB8KXlDuB6uLZGhugCqS9OJMViZ73P93dRPbphu`
          );
          xhr.onload = function () {
            if (xhr.status === 200) {
              var response = JSON.parse(xhr.responseText);
              resolve(response.addressInfo.fullAddress); // Returning the full address
            } else {
              reject("Failed to fetch address");
            }
          };
          xhr.onerror = function () {
            reject("Network request failed");
          };
          xhr.send();
        });
      }

      //#33-3 ========== 여기부터 ==========드라이버 업무 진척도를 [수평 진행률 표시줄]을 통해 표현
      //
      function loadDriverDeliveries() {
        Papa.parse("/static/deliveries.csv", {
          download: true,
          header: true,
          complete: function (results) {
            const deliveriesData = results.data;
            const deliveryCountByDriver = {};
            deliveriesData.forEach((delivery) => {
              const driverId = delivery.driver_id;
              if (deliveryCountByDriver[driverId]) {
                deliveryCountByDriver[driverId]++;
              } else {
                deliveryCountByDriver[driverId] = 1;
              }
            });
            initializeProgressBars(deliveryCountByDriver);
          },
        });
      }

      // #33-3 Driver의 업무 진척도 [수평 진행률] 생성
      function initializeProgressBars(deliveryCountByDriver) {
        const container = document.getElementById("driverWorkProcess");
        Object.keys(deliveryCountByDriver).forEach((driverId) => {
          const count = deliveryCountByDriver[driverId];
          const progressBar = document.createElement("div");
          progressBar.className = "progress-bar";
          progressBar.id = `progress-${driverId}`;
          progressBar.style.width = "100%";
          progressBar.style.border = "1px solid #ccc";

          // Label for driver ID
          const driverLabel = document.createElement("div");
          driverLabel.className = "driver-id";
          driverLabel.textContent = `Driver ${driverId}`;
          progressBar.appendChild(driverLabel);

          for (let i = 0; i < count; i++) {
            const segment = document.createElement("div");
            segment.className = "segment";
            segment.style.width = `${100 / count}%`;
            segment.style.height = "20px";
            segment.style.float = "left";
            segment.style.backgroundColor = "#eee";
            progressBar.appendChild(segment);
          }
          container.appendChild(progressBar);
        });
      }

      // #33-3 Driver의 업무 진척도 [수평 진행률] 업데이트
      function updateProgressBar(driverStateData) {
        // subscribeDriverStateTopics함수 안에서 RabbitMQ에 subscribe를 하고, message를 JSON.parse한 데이터를 바로 받아옴

        // console.log("//#33-3 데이터 수신: " + driverStateData);
        // console.log("//#33-3 드라이버 ID: " + driverStateData.driverId);
        // console.log("//#33-3 드라이버 상태: " + driverStateData.status);
        // console.log("//#33-3 드라이버 다음 도착지 위도: " + driverStateData.latitude);
        // console.log("//#33-3 드라이버 다음 도착지 경도: " + driverStateData.longitude);
        const driverId = driverStateData.driverId;
        const progressBar = document.getElementById(`progress-${driverId}`);
        if (!progressBar) {
          console.error(
            `//#33-3 Progress bar for driver ${driverId} not found!`
          );
          return;
        }
        const segments = progressBar.getElementsByClassName("segment");
        let completedCount = 0;
        for (let segment of segments) {
          if (segment.style.backgroundColor !== "green") {
            segment.style.backgroundColor = "green";
            completedCount++;
            break;
          }
        }
        console.log(
          `Driver ${driverId} has completed ${completedCount} deliveries.`
        );
      }
      //#33-3 ========== 여기까지 ==========드라이버 업무 진척도를 [수평 진행률 표시줄]을 통해 표현

      // function updateDriverLocation(driverId, location) {
      //   var locationDiv = document.getElementById("driverLocations");
      //   var existingEntry = document.getElementById("location-" + driverId);
      //   if (!existingEntry) {
      //     existingEntry = document.createElement("div");
      //     existingEntry.id = "location-" + driverId;
      //     locationDiv.appendChild(existingEntry);
      //   }
      //   existingEntry.textContent = "Driver " + driverId + ": " + location;
      // }

      fetchDrivers(); // CSV 파일로부터 driverID 받아오기(fetching) 시작
      loadDriverDeliveries(); // #33-3 Driver들의 업무 진척도 [수평 진행률] 표시

      // #33-1 지도 첫 시작 - 들어온 주문들의 중심 위치로 시작
      function initDriverMap() {
        fetch("/static/orders.csv")
          .then((response) => response.text())
          .then((data) => {
            const rows = data.split("\n").map((row) => row.split(","));
            if (rows.length < 2) return; // Ensure there is data

            // 지도에 마커 표시하기 위함
            const headers = rows[0];
            const latIndex = headers.indexOf("latitude");
            const lonIndex = headers.indexOf("longitude");

            let latSum = 0,
              lonSum = 0,
              validCount = 0;

            rows.slice(1).forEach((row) => {
              // 지도에 마커 표시하기 위함
              const latitude = parseFloat(row[latIndex]);
              const longitude = parseFloat(row[lonIndex]);

              if (!isNaN(latitude) && !isNaN(longitude)) {
                latSum += latitude;
                lonSum += longitude;
                validCount++;
              }
            });

            if (validCount > 0) {
              const centerLat = latSum / validCount;
              const centerLon = lonSum / validCount;

              //이미 지도 활성화 되었다면, just reset the center and clear old markers
              if (driverMap) {
                driverMap.setCenter(new Tmapv3.LatLng(centerLat, centerLon));
                clearMarkers(); // 이미 markers가 존재한다면, Clear
              } else {
                // (첫 활성화) 지도 활성화 - Initialize the map for the first time
                driverMap = new Tmapv3.Map("driverMapDiv", {
                  center: new Tmapv3.LatLng(centerLat, centerLon),
                  width: "100%",
                  height: "400px",
                  zoom: 12,
                });
              }
            }
          })
          .catch((error) => console.error("Error loading CSV data:", error));
      }

      // #33-1 Driver 위치 표시
      function updateDriverMap(latitude, longitude, driverId) {
        console.log("//#33-1 마커 표시할 드라이버 아이디: " + driverId);
        // 이미 해당 driverId의 마커가 존재한다면 지우기
        if (driverMarkers[driverId]) {
          driverMarkers[driverId].setMap(null);
          console.log("//#33-1 드라이버" + driverId + "에 대해서 마커 삭제");
        }

        var driverLocation = new Tmapv3.LatLng(latitude, longitude);
        console.log(
          "//#33-1 드라이버" + driverId + "의 위치를 지도에 마커로 표시"
        );
        var newDriverMarker = new Tmapv3.Marker({
          icon: "https://cdn-icons-png.flaticon.com/128/14975/14975104.png",
          label: "Driver" + driverId, // #33-1 driverId를 바탕으로 배달 기사들 표시
          position: driverLocation,
          map: driverMap,
        });

        // Update the marker in the global object
        driverMarkers[driverId] = newDriverMarker;
      }

      //  ============= //#33 [배달 관리] 페이지 - 여기까지 =============

      //  ============= //#29 [배터리 관리] 페이지 =============
      //  ============= //배터리 강화학습 코드 통합 - 여기부터=============
      // const chartCount = 5;
      // const charts = [];

      // function createDoughnutChart(ctx) {
      //   return new Chart(ctx, {
      //     type: "doughnut",
      //     data: {
      //       labels: ["State of Charge", "Remaining"],
      //       datasets: [
      //         {
      //           data: [0, 100],
      //           backgroundColor: ["#36A2EB", "#FFCE56"],
      //           hoverBackgroundColor: ["#36A2EB", "#FFCE56"],
      //         },
      //       ],
      //     },
      //     options: {
      //       responsive: true,
      //       plugins: {
      //         legend: {
      //           position: "top",
      //         },
      //         tooltip: {
      //           callbacks: {
      //             label: function (tooltipItem) {
      //               return `${tooltipItem.label}: ${tooltipItem.raw}%`;
      //             },
      //           },
      //         },
      //       },
      //     },
      //   });
      // }

      // for (let i = 0; i < chartCount; i++) {
      //   const ctx = document
      //     .getElementById(`batteryChart${i}`)
      //     .getContext("2d");
      //   charts.push(createDoughnutChart(ctx));
      // }

      // function updateChart(chart, batteryData) {
      //   const stateOfCharge = batteryData[0];
      //   chart.data.datasets[0].data = [
      //     stateOfCharge * 100,
      //     100 - stateOfCharge * 100,
      //   ];
      //   chart.update();
      // }

      // function fetchDataAndUpdateCharts() {
      //   for (let i = 0; i < chartCount; i++) {
      //     fetch(`/battery/${i}`)
      //       .then((response) => response.json())
      //       .then((data) => {
      //         updateChart(charts[i], data);
      //       })
      //       .catch((error) =>
      //         console.error("Error fetching battery state:", error)
      //       );
      //   }
      // }

      // setInterval(fetchDataAndUpdateCharts, 100); // 1분마다 업데이트

      // // Initial chart update
      // fetchDataAndUpdateCharts();

      //  ============= //#29 [배터리 관리] 페이지 =============
      //  ============= 배터리 강화학습 코드 통합 - 여기까지=============
    </script>
  </body>
</html>
